(window.webpackJsonp=window.webpackJsonp||[]).push([[52],{601:function(t,a,s){"use strict";s.r(a);var n=s(17),r=Object(n.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h2",{attrs:{id:"backtracking-是-dfs-的一种形式-基本写法类似于-top-down-dfs-但是引入状态回溯-这是什么"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#backtracking-是-dfs-的一种形式-基本写法类似于-top-down-dfs-但是引入状态回溯-这是什么"}},[t._v("#")]),t._v(" backtracking 是 DFS 的一种形式，基本写法类似于 Top Down DFS,但是引入状态回溯？ 这是什么")]),t._v(" "),s("h2",{attrs:{id:"什么是回溯算法-也叫回溯搜索法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#什么是回溯算法-也叫回溯搜索法"}},[t._v("#")]),t._v(" 什么是回溯算法 也叫回溯搜索法")]),t._v(" "),s("ul",[s("li",[t._v("本质就是暴力穷举， 穷举所有可能，然后找我们想要的答案， 回溯是下次尝试不要受上次尝试的影响")])]),t._v(" "),s("p",[t._v("1\n2\n345")]),t._v(" "),s("p",[t._v("状态 []\n[1]\n[1,2]\n[1,2,3]\n没有回溯\n[1,2,3,4]\n有回溯\n[1,2,4]")]),t._v(" "),s("h2",{attrs:{id:"不高效为什么还用它"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#不高效为什么还用它"}},[t._v("#")]),t._v(" 不高效为什么还用它？")]),t._v(" "),s("ul",[s("li",[t._v("因为能暴力搜索出来就很不错了")])]),t._v(" "),s("h2",{attrs:{id:"可以解决哪些问题"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#可以解决哪些问题"}},[t._v("#")]),t._v(" 可以解决哪些问题？")]),t._v(" "),s("ul",[s("li",[t._v("组合问题 （LeetCode 77 ）")]),t._v(" "),s("li",[t._v("排列问题")]),t._v(" "),s("li",[t._v("切割问题")]),t._v(" "),s("li",[t._v("子集问题")]),t._v(" "),s("li",[t._v("棋盘问题")])]),t._v(" "),s("h2",{attrs:{id:"组合和排列的区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#组合和排列的区别"}},[t._v("#")]),t._v(" 组合和排列的区别？")]),t._v(" "),s("p",[t._v("组合不强调顺序[1,2] 和[2,1] 等价 算是一个")]),t._v(" "),s("p",[t._v("排列强调顺序 [1,2]和[2,1] 是两个 因为顺序不同")]),t._v(" "),s("h2",{attrs:{id:"如何理解回溯法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#如何理解回溯法"}},[t._v("#")]),t._v(" 如何理解回溯法？")]),t._v(" "),s("ul",[s("li",[t._v("构建 决策树\n"),s("ul",[s("li",[t._v("树的深度是递归的深度")]),t._v(" "),s("li",[t._v("树的宽度由集合的大小构成")])])])]),t._v(" "),s("h2",{attrs:{id:"回溯和递归的关系"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#回溯和递归的关系"}},[t._v("#")]),t._v(" 回溯和递归的关系？")]),t._v(" "),s("ul",[s("li",[t._v("回溯通常由递归实现，并且在递归函数的后面 通常就是回溯的代码")])]),t._v(" "),s("h2",{attrs:{id:"回溯法的模版"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#回溯法的模版"}},[t._v("#")]),t._v(" 回溯法的模版？")]),t._v(" "),s("ul",[s("li",[s("ol",[s("li",[t._v("回溯函数模版的返回值以及参数")])])]),t._v(" "),s("li",[s("ol",{attrs:{start:"2"}},[s("li",[t._v("终止条件")])])]),t._v(" "),s("li",[s("ol",{attrs:{start:"3"}},[s("li",[t._v("单层递归逻辑")])])])]),t._v(" "),s("div",{staticClass:"language-js line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function-variable function"}},[t._v("backtracking")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("参数")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("终止条件"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        存放结果\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//一定要加return")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("for")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("选择 本层集合中的元素 "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        处理节点\n        "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("backtracking")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("路径， 选择列表"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n        回溯 撤销处理结果\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function-variable function"}},[t._v("backtrack")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1.")]),t._v(" base Case\n    "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("2.")]),t._v(" For Each possibility p\n        a"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v(" Memorize current state\n        b"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("backtrack")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("next_state"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n        c"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v(" Restore current state\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br"),s("span",{staticClass:"line-number"},[t._v("6")]),s("br"),s("span",{staticClass:"line-number"},[t._v("7")]),s("br"),s("span",{staticClass:"line-number"},[t._v("8")]),s("br"),s("span",{staticClass:"line-number"},[t._v("9")]),s("br"),s("span",{staticClass:"line-number"},[t._v("10")]),s("br"),s("span",{staticClass:"line-number"},[t._v("11")]),s("br"),s("span",{staticClass:"line-number"},[t._v("12")]),s("br"),s("span",{staticClass:"line-number"},[t._v("13")]),s("br"),s("span",{staticClass:"line-number"},[t._v("14")]),s("br"),s("span",{staticClass:"line-number"},[t._v("15")]),s("br"),s("span",{staticClass:"line-number"},[t._v("16")]),s("br"),s("span",{staticClass:"line-number"},[t._v("17")]),s("br"),s("span",{staticClass:"line-number"},[t._v("18")]),s("br"),s("span",{staticClass:"line-number"},[t._v("19")]),s("br")])]),s("h2",{attrs:{id:"leetcode-77"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#leetcode-77"}},[t._v("#")]),t._v(" LeetCode 77")]),t._v(" "),s("ul",[s("li",[t._v("for 循环嵌套超过三层就很难理解了， 递归实现的话就可以嵌套 n 层， 所以回溯算法里面的解决代码基本都是靠递归，")])]),t._v(" "),s("h2",{attrs:{id:"分几种情况"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#分几种情况"}},[t._v("#")]),t._v(" 分几种情况")]),t._v(" "),s("p",[t._v("1 元素不重复， 不可重复使用")]),t._v(" "),s("ul",[s("li",[t._v("a 子集")]),t._v(" "),s("li",[t._v("b 组合 77")]),t._v(" "),s("li",[t._v("c 排列")])]),t._v(" "),s("p",[t._v("2 元素不重复， 可重复使用")]),t._v(" "),s("ul",[s("li",[t._v("a 子集")]),t._v(" "),s("li",[t._v("b 组合 39")]),t._v(" "),s("li",[t._v("c 排列")])]),t._v(" "),s("p",[t._v("3 元素可以重复， 不可重复使用")]),t._v(" "),s("ul",[s("li",[t._v("a 子集 90")]),t._v(" "),s("li",[t._v("b 组合")]),t._v(" "),s("li",[t._v("c 排列")])]),t._v(" "),s("p",[t._v("4 元素可以重复可以重复使用， 既然可以重复，就可以重复使用了 ，和 3 一样")]),t._v(" "),s("p",[t._v("所以一共有九种情况")]),t._v(" "),s("h2",{attrs:{id:"回溯可以通过剪枝来优化-其实就是缩短决策树的宽度-暂时这么理解的"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#回溯可以通过剪枝来优化-其实就是缩短决策树的宽度-暂时这么理解的"}},[t._v("#")]),t._v(" 回溯可以通过剪枝来优化， 其实就是缩短决策树的宽度（暂时这么理解的）")]),t._v(" "),s("h2",{attrs:{id:"子集问题"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#子集问题"}},[t._v("#")]),t._v(" 子集问题")]),t._v(" "),s("p",[t._v("k 就是决策树的高度， n 就是决策树的宽度")])])}),[],!1,null,null,null);a.default=r.exports}}]);